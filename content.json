{"meta":{"title":"Meng's blog","subtitle":"","description":"欢迎来到我的博客","author":"蒙家辉","url":"https://look-ahead8.github.io/Look-Ahead8-github.io","root":"/Look-Ahead8-github.io/"},"pages":[{"title":"蒙家辉","date":"2020-02-28T04:38:32.000Z","updated":"2020-02-28T04:39:48.300Z","comments":true,"path":"about/index.html","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"红黑树详解(一)红黑树的介绍和操作","slug":"红黑树详解(一)红黑树的介绍和操作","date":"2020-02-28T12:28:27.614Z","updated":"2020-02-29T06:02:44.971Z","comments":true,"path":"2020/02/28/红黑树详解(一)红黑树的介绍和操作/","link":"","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/2020/02/28/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3(%E4%B8%80)%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%93%8D%E4%BD%9C/","excerpt":"","text":"# 红黑树详解(一)红黑树的介绍和操作 摘要: &nbsp;&nbsp;&nbsp;&nbsp;在很多源码涉及到大量数据处理的时候，通常都是用红黑树这一数据结构。红黑树是一种自平衡的二叉查找树，它能在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，获得较高的查找性能。本文将使用图文详细的分析红黑树 一、红黑树解决了什么问题​ 首先，我们要知道二叉搜索树，在不为空的情况下，左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值。它使得数据查找起来不是线性查找(O(n)),平均复杂度仅仅为O(log(n)). ​ 但是在最快情况下，二叉搜索树可能变为线性搜索，退化为链表，复杂度为O(n),那就没有意义了，如下图的情况所示。 ​ 为了避免这种情况发生，就到了我们的主角红黑树，它规定了一些性质使得这种情况不会发生。 二、红黑树的性质​ 红黑树主要有这五条性质。 1.节点不是红色就是黑色 2.根节点是黑色 3.叶子节点(NIL)为黑色 4.每个红色节点的两个子节点都是黑色。（(从每个叶子到根的所有路径上不能有两个连续的红色节点） 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 如下图所示 三、红黑树的操作​ 在进行红黑树的插入、删除时候，很可能会破坏红黑树的五条性质。因此，我们需要一些操作来维护红黑树五条性质不被破坏。主要有三种操作，变色、左旋、右旋. ​ 为了更好的理解以下操作，这里规定一些叫法。 1.变色​ 顾名思义，就是改变树结点的颜色。如果不能仅仅通过变色解决问题，就需要旋转操作。 2.左旋​ 以结点p作为支点进行左旋，其左子结点不变，右子结点变为p的右子节点的左子结点，且p的父结点变为右子结点。 ​ 支点为p，其父结点为pp，右子结点和左子结点为r和l，r的左右孩子分别为rl和rr。则示意图如下： 3.右旋&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以结点p作为支点右旋，其右子结点不变，左子结点变为其左子结点的右子结点，且p的父结点变为左子结点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支点为p，其父结点为pp，右子结点和左子结点为r和l，l的左右孩子分别为ll和lr。则示意图如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示 ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020022621231958.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzA5NTM3,size_16,color_FFFFFF,t_70) 左旋右旋实际上是一边子树的结点少了，向另外一边子树借结点。","categories":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"红黑树","slug":"红黑树","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"算法","slug":"算法","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"HashMap的工作原理和底层实现（二）红黑树的左旋、右旋","slug":"HashMap的工作原理和底层实现（二）红黑树的左旋、右旋","date":"2020-02-28T12:27:52.858Z","updated":"2020-02-29T06:02:02.014Z","comments":true,"path":"2020/02/28/HashMap的工作原理和底层实现（二）红黑树的左旋、右旋/","link":"","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/2020/02/28/HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%B7%A6%E6%97%8B%E3%80%81%E5%8F%B3%E6%97%8B/","excerpt":"","text":"HashMap中的红黑树左旋、右旋 摘要: &nbsp;&nbsp;&nbsp;&nbsp;HashMap是java最常用的容器之一，本文会通过阅读源码的方式来理解HashMap中是如何进行红黑树的左旋和右旋 一、什么是左旋和右旋 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;红黑树的性质 每个节点要么是黑色，要么是红色。 根节点是黑色。 每个叶子节点（NIL）是黑色。 每个红色结点的两个子结点一定都是黑色。 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每当对红黑树结点进行增删改的时候可能会破坏红黑树的性质，因此我们需要维持这5条性质。有三种方式:变色、左旋、右旋.变色简单，本文会根据HashMap的源码分析左旋和右旋 1)左旋 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以结点p作为支点进行左旋，其左子结点不变，右子结点变为p的右子节点的左子结点，且p的父结点变为左子结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支点为p，其父结点为pp，右子结点和左子结点为r和l，r的左右孩子分别为rl和rr。则示意图如下： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216142519497.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzA5NTM3,size_16,color_FFFFFF,t_70) 2)右旋 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以结点p作为支点右旋，其右子结点不变，左子结点变为其左子结点的右子结点，且p的父结点变为右子结点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216142212451.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzA5NTM3,size_16,color_FFFFFF,t_70) 二、HashMap对左旋右旋的实现 ##### （1)左旋 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源码如下 ```java //root为根节点，p为旋转的结点 static TreeNode rotateLeft(TreeNode root, TreeNode p) { TreeNode r, pp, rl; if (p != null && (r = p.right) != null) { //如果p不为空且存在右子结点r if ((rl = p.right = r.left) != null) //判断右子结点的左子结点rl存在 rl.parent = p; //存在设置rl的父节点为p if ((pp = r.parent = p.parent) == null) //判断p的父节点pp是否存在 (root = r).red = false; //如果不存在设置新的根节点为r且黑色 else if (pp.left == p) //父结点pp存在且p为pp的左子结点 pp.left = r; else //父结点pp存在且p为pp的左子结点 pp.right = r; r.left = p; p.parent = r; } return root; } ``` 形参root为红黑树的根节点，因为左旋和右旋可能会改变根节点，p为旋转的结点，r为p的右子节点，pp为【的父节点，rl为r的左子结点。返回值为根结点.旋转分如下步骤 1.如果结点p为空或者p不存在右子结点r（此时完成不了旋转）,则直接返回，否则继续如下步骤. 2.如果rl不为空，则使p的右边等于rl。否则如果rl为空则不用操作，直接下一步 3.如果p没有父结点，即他本身就是根节点，那么设置r为根节点，并设置r为黑色（红黑树的性质2）.如果p父结点存在且p为父结点的左子结点，则父结点的左子结点设置为r。如果p父结点存在且p为父结点的右子节点，则父结点的右子结点设置为r。 4.最后把r的左子节点设置为p，p的父结点设置为r （2)右旋​ 右旋和左旋类似 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源码如下 ```java //root为根节点，p为旋转的结点 static TreeNode rotateRight(TreeNode root, TreeNode p) { TreeNode l, pp, lr; if (p != null && (l = p.left) != null) { //如果p不为空且存在左子结点l if ((lr = p.left = l.right) != null) //判断左子结点的右子结点lr存在 lr.parent = p; //存在则设置rl的父结点为p if ((pp = l.parent = p.parent) == null) //判断p的父结点pp是否存在 (root = l).red = false; //如果不存在设置新的根节点为l且l为黑色 else if (pp.right == p) //父结点pp存在且p为pp的右子结点 pp.right = l; else //父结点pp存在且p为pp的左子结点 pp.left = l; l.right = p; p.parent = l; } return root; } ``` p为旋转的结点，l为p的左子节点，pp为p的父节点，lr为l的右子结点。返回值为根结点.旋转分如下步骤 1.如果结点p为空或者p不存在左子结点r（此时完成不了旋转）,则直接返回，否则继续如下步骤. 2.如果lr不为空，则使p的左边等于lr。否则如果lr为空则不用操作，直接下一步 3.如果p没有父结点，即他本身就是根节点，那么设置l为根节点，并设置l为黑色（红黑树的性质2）.如果p父结点存在且p为父结点的左子结点，则父结点的左子结点设置为l。如果p父结点存在且p为父结点的右子节点，则父结点的右子结点设置为l。 4.最后把l的左子节点设置为p，p的父结点设置为l","categories":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/java/"},{"name":"hashmap","slug":"hashmap","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/hashmap/"},{"name":"数据结构","slug":"数据结构","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"红黑树","slug":"红黑树","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"}]},{"title":"蓝桥杯 算法训练 最大值路径（动态规划)","slug":"蓝桥杯 算法训练 最大值路径（动态规划)","date":"2020-02-28T12:27:27.911Z","updated":"2020-02-29T06:04:47.216Z","comments":true,"path":"2020/02/28/蓝桥杯 算法训练 最大值路径（动态规划)/","link":"","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/2020/02/28/%E8%93%9D%E6%A1%A5%E6%9D%AF%20%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%20%E6%9C%80%E5%A4%A7%E5%80%BC%E8%B7%AF%E5%BE%84%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)/","excerpt":"","text":"## 蓝桥杯 算法训练 最大值路径（动态规划） 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 刷微博，编程序。如下图所示，@北京发布 提出了如下“头脑震荡”问题。对此问题做一般化描述： 有n阶方阵，从矩阵的左下角元素为起点，从行或列（水平或垂直）两个方向上移动，直到右上角。求出有多少条路径可以使得经过的元素累加值最大，最大值是多少。 输入格式 共有n+1行。 第一行整数n，表示矩阵的阶数，2&lt;=n&lt;=10。 第二行起，每行n个整数，以空格分隔，共n行。 输出格式 一行，两个空格分隔的数，第一个表示最大值路径的条数，第二个表示最大值。 样例输入 54 5 4 5 62 6 5 4 62 6 6 5 24 5 2 2 55 2 5 6 4 样例输出 3 47 ​ 首先这题很常规，和leetcode这道题很相似。https://leetcode-cn.com/problems/minimum-path-sum/，不过这题求的最大路径而已。难点在于还要输出最大值路径的条数，需要我们再返回去递归搜索。 确认dp数组的含义​ 使用二维数组dp,其中dp[i][j]表示从左下角到第i+1行j+1列的最大值.最后答案就是dp[0][n-1] 找到状态转移方程​ 因为只能从上面或者右边走，所以每一步的最大值就等于它左边的和下边的最大值再加上这地方本来的值。因此状态转移方程. ​ 状态转移方程:dp[i][j]=Max(dp[i+1][j],dp[i][j-1])+nums[i][j]. 填表赋初始值​ 表格如下 i\\j 0 1 2 3 4 0 1 2 3 4 ​ 对于状态转移方程，对于最后一行和第一列是没办法填写的，需要我们手动赋初始值。起点即为本身的数值，剩下的最后一行走法只可能一直往右走，因为就是左边的相加对应的数值，第一列也是相似。因此填完初始值后如下。 i\\j 0 1 2 3 4 0 17 1 13 2 11 3 9 4 5 7 12 18 22 ​ 剩下的，我们需要根据状态转移方程从到数第二行开始填写,最后如下： i\\j 0 1 2 3 4 0 17 31 35 40 47 1 13 26 31 35 41 2 11 20 26 31 33 3 9 14 16 20 27 4 5 7 12 18 22 路径的总数​ 这和以往的dp不同，还需要找相同路径的总数。我们定义为result,result初始值肯定为1，因为他必定有1条。然后我们需要从终点出发，即dp[0][n-1],然后比较他的左边和下面，如果值相同的就result++，因为有说明有两条分支，其中一支已经就是result=1那支了，所以需要加1。如果不相同，就取最大那个值进行递归再查找分支。 最终代码import java.util.Scanner; /** * @author Meng * @date 2020/2/3 */ public class Main { private static int n; private static int[][] dp; private static int result=1; /** * 递归查找最大值的路径总数 * @param x * @param y */ private static void total(int x, int y) { if(x+1&gt;n-1||y-1&lt;0){ return; } if(x==n-1&amp;&amp;y==0){ return; } if (dp[x][y - 1] &gt; dp[x + 1][y]) { total(x, y - 1); } else if (dp[x][y - 1] &lt; dp[x + 1][y]) { total(x + 1, y); }else{ result++; total(x, y - 1); total(x + 1, y); } } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); int[][] arr = new int[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { arr[i][j] = scanner.nextInt(); } } dp = new int[n][n]; //起点赋初值 dp[n - 1][0] = arr[n - 1][0]; //第一列赋初始值 for (int i = n - 2; i &gt;= 0; i--) { dp[i][0] = arr[i][0] + dp[i + 1][0]; } //最后一行赋初始值 for (int i = 1; i &lt; n; i++) { dp[n - 1][i] = arr[n - 1][i] + dp[n - 1][i - 1]; } for (int i = n - 2; i &gt;= 0; i--) { for (int j = 1; j &lt; n; j++) { dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]) + arr[i][j]; } } //查找符合条件路径数量 total(0,n-1); System.out.println(result + &quot; &quot; + dp[0][n - 1]); } }","categories":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/"},{"name":"蓝桥杯","slug":"java/蓝桥杯","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"dfs","slug":"dfs","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/dfs/"}]},{"title":"蓝桥杯 算法训练 K好数（动态规划）","slug":"蓝桥杯 算法训练 K好数（动态规划）","date":"2020-02-28T12:07:06.761Z","updated":"2020-02-29T06:04:36.538Z","comments":true,"path":"2020/02/28/蓝桥杯 算法训练 K好数（动态规划）/","link":"","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/2020/02/28/%E8%93%9D%E6%A1%A5%E6%9D%AF%20%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%20K%E5%A5%BD%E6%95%B0%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/","excerpt":"","text":"## 蓝桥杯 算法训练 K好数（动态规划） 资源限制 时间限制：1.0s 内存限制：256.0MB 问题描述 如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。 输入格式 输入包含两个正整数，K和L。 输出格式 输出一个整数，表示答案对1000000007取模后的值。 样例输入 4 2 样例输出 7 数据规模与约定 对于30%的数据，KL &lt;= 106； 对于50%的数据，K &lt;= 16， L &lt;= 10； 对于100%的数据，1 &lt;= K,L &lt;= 100。 ##### 思路 ​ 首先看到要取模，大概率不能用深搜暴力，且数据规模较大,深搜只能过百分之30的数据。而我们一一列出来的时候，是可以根据L-1的情况填数的，故有依赖于子结构，所以我们用动态规划。 1.确立dp数组的含义​ 对于这种连续数字的，我们一般都根据末尾来存储状态，以及上文提到过的还要根据L的状态，所以我们需要一个二维数组dp。dp[i][j]表示在L=i时末位为J有多少种。每次填充数组时候都需要进行取模的运算。最后的答案就是对i=L的情况下J从1到K-1进行叠加。为什么是这样，往后看。 2.找到状态转移方程​ 思考一下，在L=1的时候有0，1，2，3总共4种。如果我们要天下L=1且结尾J=1的情况，且不能够相邻。我们只用在1和3后面加1，即11和13两种，所以就是把不相邻的情况加起来就行了。注意，虽然最后答案不存在以0开头的数字，但是在计算的时候我们也要计算，不然如果求解K=4，L=3的情况下，类似200这种情况就算不到，因为在L=2的时候我们不算00这种情况。所以最后需要从1到K-1进行叠加而不是0到K-1进行叠加。举个例子，按照这个状态转移方程算出来如下。 ​ 总共 i=2,j=0 00 20 30 3 i=2,j=1 11 31 2 i=2,j=2 02 22 2 i=2,j=3 03 13 33 3 ​ 多出来的0开头的就相当于J=0的时候调转过来，所以数目是一样的，因此就是对于dp数组i=L情况下j从0到K-1叠加减去i=0,就相当于对i=L的情况下J从1到K-1进行叠加。 3.填表并赋初始值​ 以K=4，L=3为分析 ​ 对于前面的分析，表格如下 i\\j 0 1 2 3 0 1 2 3 ​ 因为我们每填一个表格都需要i-1的情况，因此在i=0时候是没有的，而i=0没有意义我们不管就是默认值0，然后i=1一位数的情况是不管以什么结尾都是只有1种情况，最后填完初始表格如下。 i\\j 0 1 2 3 0 0 0 0 0 1 1 1 1 1 2 3 ​ 最后根据状态转移方程完善表格，如下 i\\j 0 1 2 3 0 0 0 0 0 1 1 1 1 1 2 3 2 2 3 3 8 5 5 8 最后答案就是i=3,j=1,2,3（直到K-1）相加，结果为5+5+8=13.最后写代码时候记得取余，因为a+b=c，则a%x+b%x=c%x. 最终代码import java.util.Scanner; /** * @author Meng * @date 2020/2/1 */ public class Main { public static void main(String[] args) { Scanner scanner=new Scanner(System.in); int K=scanner.nextInt(); int L=scanner.nextInt(); int[][] dp=new int[L+1][K]; for(int i=0;i&lt;K;i++){ dp[1][i]=1; } for(int i=2;i&lt;L+1;i++){ for(int j=0;j&lt;K;j++){ for(int k=0;k&lt;K;k++){ if(Math.abs(k-j)!=1){ dp[i][j]+=dp[i-1][k]; dp[i][j]%=1000000007; } } } } int result=0; for(int i=1;i&lt;K;i++){ result+=dp[L][i]; result%=1000000007; } System.out.println(result); } }","categories":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/"},{"name":"蓝桥杯","slug":"java/蓝桥杯","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"dfs","slug":"dfs","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/dfs/"}]},{"title":"实践中理解动态规划(简单详细)","slug":"实践中理解动态规划(简单详细)","date":"2020-02-28T12:03:45.541Z","updated":"2020-02-29T06:05:00.220Z","comments":true,"path":"2020/02/28/实践中理解动态规划(简单详细)/","link":"","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/2020/02/28/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(%E7%AE%80%E5%8D%95%E8%AF%A6%E7%BB%86)/","excerpt":"","text":"实践中理解动态规划(简单详细) 摘要: &nbsp;&nbsp;&nbsp;&nbsp;动态规划（dp）是算法比赛中常考的算法，个人感觉也是最有难度的算法。因此本文会介绍动态规划在实践中的几个步骤来理解动态规划 一、什么是动态规划​ 动态规划就是问题的最优解如果可以由子问题的最优解推导得到，则可以先求解子问题的最优解，在构造原问题的最优解； ​ 简单来说就是当前这个问题依赖于子问题，例如斐波那契数列f[n]=f[n-1]+f[n-2]，f[1]=1,f[2]=2。我们要求解的f[n]这个问题就依赖于f[n-1]和f[n-2]这个问题. 二、动态规划的解题步骤1.确定dp数组的含义​ 基本上全部的动态规划题目不考虑空间优化情况下都可以用一维或二维数组存储状态，我们需要确认该数组的下标及其该数组的值所表示的含义. 2.找到状态转移方程​ 在确认了dp数组的含义后，接着就要寻找状态转移方程，这也是整个步骤中最难的一个部分。以我举的例子来说，f[n]=f[n-1]+f[n-2]就是状态转移方程，难的动态规划题就是难在状态转移方程想不出来。有了状态转移方程，接下来最后一步就简单很多了。 3.填表并赋初始值​ 有了状态转移方程我们可以自己尝试画一下表格，对于一些不能通过状态转移方程填写的地方，就要我们手动赋予初始值。简单的状态转移方程可以直接看到哪里要赋初始值，例如斐波那契数列，明显n-1&gt;0和n-2&gt;0，因此n=1和n=2需要我们手动赋值。但是刚上手的话还是画一下表格容易理解。 三、实践中理解动态规划我们尝试用这三个步骤求解一下简单的动态规划题目。 （1）爬楼梯这是leetcode的一道原题，https://leetcode-cn.com/problems/climbing-stairs/。 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 1.确定dp数组的含义​ 本题属于动态规划中最基础的一题，我们只用一个一维数组dp来存储状态，i表示第i个阶梯，dp[i]表示爬到第i个阶梯总共有多少种不同的方法。当i=n时，即求出解。 2.找到状态转移方程​ 这个需要动一点脑筋，因为一次只能走1步或者2步，我们在第三个阶梯的时候就是在走第一个阶梯的时候走2布到第三个阶梯或者在走到第二个阶梯时候走1布到三个阶梯。因此走到第三个阶梯的方法就是走到第一个阶梯的方法加上走到第二个阶梯的方法。 ​ 状态转移方程:dp[i]=dp[i-2]+dp[i-1] 3.填表并赋初始值​ 仔细一看其实状态转移方程就是斐波那契数列，很明显我们对于i=2和i=1赋初始值。但是我们还是填表，等熟悉了才跳过。 i 0 1 2 3 dp[i] ​ 因为数组下标是以0开始的，我们会发现多出一列。那是因为我们第一步规定了i表示第i个阶梯。如果我们规定i表示第i+1个阶梯，则可以省掉一列,因此后者更优。因此第一步是基础，会影响我们后边的操作。 ​ 通过表格我们发现，值根据状态转移方程无法填写i=0,1,2的情况。因此我们需要赋予初值，0 是无意义的，我们就直接给定java数组默认值0，而i=1时候，即走第一个阶梯我们只需要一步，就1种情况.dp[1]=1.i=2时候，我们有两种走法，测试用例已经给出，dp[2]=2.因此赋予初始值后表格如下。 i 0 1 2 3 dp[i] 0 1 2 ​ 剩下的则是根据状态转移方程填写. i 0 1 2 3 dp[i] 0 1 2 3 4.最终代码i表示第i个阶梯 class Solution { private int[] dp; public int climbStairs(int n){ dp=new int[n+1]; dp[1]=1; if(n&gt;=2)dp[2]=2; for(int i=3;i&lt;n+1;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; } } i表示第i+1个阶梯 class Solution { private int[] dp; public int climbStairs(int n){ dp=new int[n]; dp[0]=1; if(n&gt;1)dp[1]=2; for(int i=2;i&lt;n;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n-1]; } } ​ 实际上，很多动态规划题都可以进行空间优化，不用数组存储状态，这里我们之后再说。这篇文章从简单开始，因此全都会用数组存储。 （2）不同路径这也是leetcode的一道原题，链接https://leetcode-cn.com/problems/unique-paths/. 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向右 -&gt; 向下 2. 向右 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向右 1.确定dp数组的含义​ 因为是二维矩阵，我们需要一个二维数组dp来存储状态，i表示行号，j表示列号。有了上一题的经验，dp[i][j]表示走到i+1行j+1列的可能的路径. 2.找到状态转移方程​ 因为每一次只能向下和向右移动，我们根据爬楼梯那题。每个状态的可能的路径就相当于他的上面往下走一步，左边往右走一步。 ​ 状态转移方程dp[i][j]=dp[i-1][j]+dp[i][j-1] 3.填表并赋初始值​ 你可以通过计算得出需要填初始值的地方，也可以进行画表格的形式。如果计算的话，要满足i-1&gt;0且j-1&gt;0,得到i&gt;1且j&gt;1。但还不是很直观，我们以7*3画表格看看. ​ i\\j 0 1 2 3 4 5 6 0 1 2 ​ 根据状态转移方程，每一格就相当于左边的数字加上边的数字.但是有3种特殊情况，第一行是没有上边的，第一列是没有左边的，而dp[0][0]即没有左边也没有右边。需要我们赋初值，首先dp[0][0]=1，因为起点和终点相同也有一条路径，虽然不用走。然后第一行的话都是1，因为只能一直向右走这条路径，同理第一列也是. ​ 填好初始值后 i\\j 0 1 2 3 4 5 6 0 1 1 1 1 1 1 1 1 1 2 1 ​ 接下来就十分简单了，我们把表完善. i\\j 0 1 2 3 4 5 6 0 1 1 1 1 1 1 1 1 1 2 3 4 5 6 7 2 1 3 6 10 15 21 28 ​ dp[2][6]即我们的答案. ​ 最终代码如下: class Solution { public int uniquePaths(int m, int n) { int[][] dp=new int[m][n]; dp[0][0]=1; for (int i = 1; i &lt; m; i++) { dp[i][0]=1; } for (int i = 1; i &lt; n; i++) { dp[0][i]=1; } for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; } } (3).最大子序和这题也是leetcode的原题，链接https://leetcode-cn.com/problems/maximum-subarray/ 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 1.确定dp数组的含义​ 这题比之前稍微增加了难度，对于求解连续问题的，最优解一般于连续子数组的开头结尾有关，这里我们尝试用结尾，来确立一个dp数组.dp[i]表示以nums[i]结尾的最大和子数组 2.找到状态转移方程​ 首先，我们思考我们如何找到确定结尾数字的最大和的连续子数组取决于他前一位数字结尾的最大值是否大于0.如果他的前一位数字结尾的最大值小于0 ，加上当前数字必定变小，因此当前状态的最大值就是本身。如果他的前一位数字结尾的最大值大于0，那么当前状态的最大值就是前一个状态的数值加上本身。等于0的情况两种都可以，这里随便取一种。因此状态转移方程： ​$$dp[i]=\\begin{cases}nums[i]&amp; \\text{dp[i-1]&lt;=0}\\dp[i-1]+nums[i]&amp; \\text{dp[i-1]&gt;0}\\end{cases}$$​ 举个例子，以nums[1]=1结尾的最大和子数组dp[1]=1，因为dp[0]=nums[0]=-2是小于0，所以dp[1]=nums[1]. ​ 以nums[2]=-3结尾的最大和子数组dp[2]=-2(1,-3),以为dp[1]=1大于0，所以dp[2]=dp[1]+nums[2]=-2. 3.填表并赋初始值表格如下: i 0 1 2 3 4 5 6 7 8 dp[i] 我们发现根据状态转移方程每填一个表格都需要左边的表格的数值，因此当i=0的时候我们是填不了的。因此我们需要为i=0赋予初始值.以nums[0]结尾的子数组的最大值很明显就是他本身，因此dp[0]=nums[0] 赋初始值后如下： i 0 1 2 3 4 5 6 7 8 dp[i] -2 最后根据状态转移方程完成表格 i 0 1 2 3 4 5 6 7 8 dp[i] -2 1 -2 4 3 5 6 1 5 我们只需要维护一个最大值max作为我们答案即可，很明显根据表格得到结果6. 4.代码如下class Solution { public int maxSubArray(int[] nums) { int max=nums[0]; int len=nums.length; int[] dp=new int[len]; dp[0]=nums[0]; for (int i = 1; i &lt; len; i++) { if(dp[i-1]&lt;=0)dp[i]=nums[i]; else dp[i]=dp[i-1]+nums[i]; max=Math.max(max,dp[i]); } return max; } } （4)01背包​ 接下来就要提高难度了，学习动态规划必须回的01背包问题。可以去蓝桥杯的练习系统提交或者https://www.dotcpp.com/oj/problem1924.html提交。 ```html题目描述给定N个物品,每个物品有一个重量W和一个价值V.你有一个能装M重量的背包.问怎么装使得所装价值最大.每个物品只有一个. 输入输入的第一行包含两个整数n, m，分别表示物品的个数和背包能装重量。以后N行每行两个数Wi和Vi,表示物品的重量和价值 输出输出1行，包含一个整数，表示最大价值。 样例输入3 52 33 54 7 样例输出8 ``` 1.确定dp数组的含义​ 首先我们需要数组存储输入的数据，我们分别用w和v数组存储重量和价值，即w[i]表示第i件物品的重量，v[i]表示第i件物品的价值,最后使用二维数组dp存储状态，dp[i][j]表示对于前i件物品在重量为j的情况下所装的最大价值. ​ dp[n][m]则表示解 2.寻找状态转移方程​ 思考一下，对于前i件物品在重量为j的情况下的最大价值，我们需要查看当前这件物品的重量w[i]是否大于j，如果大于了就表示这件物品放不下，那他的最大值就和前i-1件物品重量为j的值相同，即dp[i-1][j]. ​ 如果w[i]&lt;=j,即表明对于前i件物品重量为j的情况下能够放下当前物品，那么我们到底放不放这件物品，就需要进行比较了。如果不放，那就是dp[i-1][j],如果放了，就是dp[i-1][j-w[i]]+v[i],j-w[i]表示放入这件物品前的重量，整体加上v[i]就是放入这件物品前的最大值加上这件物品的价值。 ​ 状态转移方程:$$dp[i][j]=\\begin{cases}dp[i-1][j]&amp; \\text w[i]&lt;j\\Max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])&amp; \\text w[i]&gt;=j\\\\end{cases}$$ 3.填表并赋初始值对于测试用例，表格如下 i\\j 0 1 2 3 4 5 0 1 2 3 很明显，当i=0或j=0时候，我们根据状态方程求不出，且这是没有意义的.就是默认值0. i\\j 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 2 0 3 0 当i=1且j=1时候，因为w[1]=3&gt;j,放不下该物品,dp[1][1]=dp[1-1][1]=0. i=1且j=2时候，w[1]=2=j,可以放下该物品，就比较放该物品和不放该物品哪个的价值大.dp[0][2]=0,dp[i-1][j-w[i]]+v[i]=dp[0][0]+v[1]=3,很明显，3更大,因此dp[1][2]=3 同理的，当i=1时候都是3，因为dp[i-1][j]=0. 填写完i=1时候 i\\j 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 0 3 3 3 3 2 0 3 0 i=2且j=1时候，w[2]=3,v[2]=5.w[2]&gt;j,放不下，dp[2][1]=dp[1][1]=0 i=2且j=2时候，同理,dp[2][2]=dp[1][2]=3 i=2且j=3时候，w[2]=j=3,可以放的下，比较放于不放谁大.不放时候dp[1][3]=3,放的话dp[i-1][j-w[i]]+v[i]=dp[1][0]+v[2]=5,明显5大于3 特别的是i=2且j=5时候，是8 i\\j 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 0 3 3 3 3 2 0 0 3 5 5 8 3 0 把剩下填完，最后如下： i\\j 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 0 3 3 3 3 2 0 0 3 5 5 8 3 0 0 3 5 7 8 4.代码如下public class Main { public static void main(String[] args) { Scanner scanner=new Scanner(System.in); int n=scanner.nextInt(); int m=scanner.nextInt(); int[] w=new int[n+1]; int[] v=new int[n+1]; for (int i = 1; i &lt; n+1; i++) { w[i]=scanner.nextInt(); v[i]=scanner.nextInt(); } int[][] dp=new int[n+1][m+1]; for(int i=1;i&lt;n+1;i++){ for(int j=1;j&lt;m+1;j++){ if(w[i]&gt;j)dp[i][j]=dp[i-1][j]; else dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); } } System.out.println(dp[n][m]); } }","categories":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/"},{"name":"算法","slug":"java/算法","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"动手实现一个破产版tomcat","slug":"动手实现一个破产版tomcat","date":"2020-02-28T12:02:44.632Z","updated":"2020-02-29T06:01:34.875Z","comments":true,"path":"2020/02/28/动手实现一个破产版tomcat/","link":"","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/2020/02/28/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%A0%B4%E4%BA%A7%E7%89%88tomcat/","excerpt":"","text":"# 一步一步实现一个破产版tomcat tomcat服务器在我们java后台开发中可以说是经常接触到的,每次当我们写好我们的程序时，都要启动tomcat才能生效。 那么我们有没有想过tomcat到底为我们完成了什么事情？再进一步的说，我们开发时肯定离不开Servlet，那就有一个疑问为什么我们写好的Sevlet并不需要编写一个main函数new一个示例就可以生效执行我们的代码？其实这些工作都是由tomcat默默帮我们完成了。接下来我们可以自己写一个简易的破产版tomcat来简单的理解其中的奥妙。 一、动手前的准备工作 1.对HTTP协议有所了解 2.了解对javase的io流操作 3.了解javase的Socket编程 4.了解java的反射机制 如果你已经准备好了，那么现在就开始和我一起动手吧 二、需求分析 1.建立一个专门存放静态资源文件的WebContent文件夹，并能够在浏览器实现对静态资源的访问 2.能够实现浏览器对Servlet的访问(即对动态资源的访问) 3.在浏览器发送shutdown能实现对tomcat的关闭。 三、实现对静态资源文件的访问 首先，我们需要打开ide创建好项目，并且在项目的路径下创建WebContent文件夹存放我们写好的html文件，demo_1.html和demo_2.html,并创建好存放我们代码的包，里面包含TomcatServer类来完成我们本次的工作。结构图如下: demo_01.html内容如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;demo_01.html&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是demo_01html&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; demo_02.html内容如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;demo_02.html&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是demo_02.html&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 接下来终于进入正题了.我们的服务器需要处理对WebContent目录中的静态资源的请求，因此我们需要定义一个final常量WEB_ROOT来存放WebContent的路径，同时还要考虑到良好的跨平台性。我们可以这样写。 private static final String WEB_ROOT=System.getProperty(&quot;user.dir&quot;)+File.separator+&quot;WebContent&quot;; 我们还需要一个变量url存放客户端请求的资源（即端口号后面的部分） private static String url = &quot;&quot;; 最后我们还需要一个常量存放停止tomcat命令，和一个布尔变量判断是否停止 private static final String SHUTDOWN_COMMAND=&quot;SHUTDOWN&quot;; private static boolean shutdown=false; 经过这些工作之后我们终于可以写我们的main函数，我监听的是8080端口 public static void main(String[] args) { ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; OutputStream out = null; try { serverSocket = new ServerSocket(8080); while (!shutdown) { socket = serverSocket.accept(); is = socket.getInputStream(); out = socket.getOutputStream(); //解析http请求并完成对url的赋值 parse(is); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != is) { is.close(); } if (null != out) { out.close(); } if (null != socket) { socket.close(); } } catch (Exception e) { e.printStackTrace(); } } } 对于parse(is)函数，我们通过输入流获取到全部的http请求（http请求的发送在客户端的浏览器已经帮我们完成了）。 /** * 解析http请求 */ private static void parse(InputStream is) throws IOException { StringBuffer httprequest=new StringBuffer(2048); byte[] bytes=new byte[2048]; int len=is.read(bytes); httprequest.append(new String(bytes, 0, len)); //获取url,parseurl(httprequest)函数完成后记得去掉注释 //parseurl(httprequest); System.out.println(httprequest); } 然后我们在浏览器中输入http://localhost:8080/demo01.html控制台打印，成功获取到了http请求 GET /demo_01.html HTTP/1.1 Host: localhost:8080 Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.157 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 现在要完成parseurl(is)函数，就是要获取到http请求行中的demo_01.html，通过简单的字符串操作就行了. /** * 获取http请求中的请求资源名 * @param httprequest */ private static void parseurl(StringBuffer httprequest) { int index1, index2; index1 = httprequest.indexOf(&quot; &quot;); if (index1 != -1) { index2 = httprequest.indexOf(&quot; &quot;, index1 + 1); if (index2 &gt; index1) { url = httprequest.substring(index1 + 2, index2); } System.out.println(url); } } } 再次在浏览器发起请求，可以发现控制台打印的正是我们要请求的资源名称。 请求工作完成后，接下来就是发送静态资源的响应工作了，代码如下 /** * 发送静态资源文件 */ private static void sendStaticResource(OutputStream out) { byte[] bytes = new byte[2048]; FileInputStream fis = null; try { File file = new File(WEB_ROOT, url); ／／如果文件存在就把该文件内容发送到客户端的浏览器 if (file.exists()) { out.write(&quot;HTTP/1.1 200 OK\\n&quot;.getBytes()); out.write(&quot;Server:Apache-Coyote/1.1\\n&quot;.getBytes()); out.write(&quot;Content-Type:text/html;charset=utf-8\\n&quot;.getBytes()); out.write(&quot;\\n&quot;.getBytes()); fis = new FileInputStream(file); int len = fis.read(bytes); while (len != -1) { out.write(bytes, 0, len); len = fis.read(bytes); } } else { out.write(&quot;HTTP/1.1 404 not found\\n&quot;.getBytes()); out.write(&quot;Server:apache-Coyote/1.1\\n&quot;.getBytes()); out.write(&quot;Content-Type:text/html;charset=utf-8\\n&quot;.getBytes()); out.write(&quot;\\n&quot;.getBytes()); String errorMessage = &quot;file not found&quot;; out.write(errorMessage.getBytes()); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != fis) { fis.close(); } } catch (Exception e) { e.printStackTrace(); } } } 虽然代码是有点长，但是逻辑是十分的简单的，我们把获取到的静态资源名称（即url）去到存放静态资源文件的WebContent文件夹去查找，如果存在就返回200和文件中的内容，不存在就返回404和file not found错误信息。更多的是要熟悉http协议，因此我才在最前面提醒要了解常用http协议. 接下来我们把该函数放入main函数进行测试，我们在浏览器输入http://localhost:8080/demo_01.html，显示如下: 在浏览器输入http://localhost:8080/demo_02.html显示如下： 四、实现对动态资源的访问 首先我们要模仿实现一个简易的Servlet,因此我们创建一个Servlet接口,并且拥有如下生命周期，我们直接使用InputStream和OutputStream作为参数 /** * init创建之后执行 * service请求后执行 * destroy销毁后执行 */ public interface Servlet { public void init(); public void service(InputStream is, OutputStream out); public void destroy(); } 然后创建两个类Servlet_01和Servlet_02来实现该接口成为一个Servlet,分别如下 public class Servlet_01 implements Servlet{ @Override public void init() { System.out.println(&quot;Servlet_01被创建&quot;); } @Override public void service(InputStream is, OutputStream out) { System.out.println(&quot;Servlet_01被执行&quot;); } @Override public void destroy() { System.out.println(&quot;Servlet_01被销毁&quot;); } } public class Servlet_02 implements Servlet{ @Override public void init() { System.out.println(&quot;Servlet_02被创建&quot;); } @Override public void service(InputStream is, OutputStream out) { System.out.println(&quot;Servlet_02被执行&quot;); } @Override public void destroy() { System.out.println(&quot;Servlet_02被销毁&quot;); } } ​ 在我们平时写完Servlet之后我们就需要在xml中进行配置或者在高版本的Servlet中进行注解配置。为了节省篇幅，这里我们使用properties文件进行配置Servlet映射让我们的tomcat服务器能够找到. 在WebContent下创建mapper.properties文件，并添加如下内容 Servlet1=com.tuling.mytomcat.Servlet_01 Servlet2=com.tuling.mytomcat.Servlet_02 同时我们需要在服务器一启动就能够把我们的配置文件内容进行加载，因此我们需要添加一个static代码块加载配置文件和一个Map存放键值对。代码如下: private static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();//存放配置文件中的键值信息 /** * 服务器一启动就加载配置文件 */ static{ Properties prop = new Properties(); try { prop.load(new FileInputStream(WEB_ROOT + File.separator + &quot;conf.properties&quot;)); Set set = prop.keySet(); Iterator iterator = set.iterator(); //迭代操作 while (iterator.hasNext()) { String key = (String) iterator.next(); String value = prop.getProperty(key); map.put(key, value); } } catch (IOException e) { e.printStackTrace(); } } 然后我们就可以写一个方法利用java的反射机制动态的创建对象实例，并执行他的方法 /** * 发送动态资源 */ private static void sendDynamicResource(InputStream is,OutputStream out) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException { out.write(&quot;HTTP/1.1 200 OK\\n&quot;.getBytes()); out.write(&quot;Server:apache-Coyote/1.1\\n&quot;.getBytes()); out.write(&quot;Content-Type:text/html;charset=utf-8\\n&quot;.getBytes()); out.write(&quot;\\n&quot;.getBytes()); //如果配置文件中的键匹配则创建Servlet实例并执行方法 if (map.containsKey(url)) { String value = map.get(url); Class clazz = Class.forName(value); Servlet servlet = (Servlet) clazz.newInstance(); servlet.init(); servlet.service(is,out); } } 最后我们添加该方法到主函数，但我们还要判断请求的资源是动态还是静态，在这里我们简单的用后缀名判断，有后缀名就是静态，没有后缀名就是动态。主函数修改如下。 if (null != url) { if (url.indexOf(&quot;.&quot;) != -1) { //如果有后缀名 sendStaticResource(out); } else { sendDynamicResource(is,out); } } 进行测试，我们浏览器输入http://localhost:8080/Servlet1然后进行关闭，再输入http://localhost:8080/Servlet2，控制台打印结果。 五、程序的关闭 //main函数修改如下 if (null != url) { if(!url.equals(SHUTDOWN_COMMAND)) { if (url.indexOf(&quot;.&quot;) != -1) { sendStaticResource(out); } else { sendDynamicResource(is, out); } } else{ shutdown=true; } } 当我们发送http://localhost:8080/SHUTDOWN程序关闭 六、总结 最终的源码如下 public class TomcatServer { private static final String WEB_ROOT = System.getProperty(&quot;user.dir&quot;) + File.separator + &quot;WebContent&quot;; private static String url = &quot;&quot;; private static final String SHUTDOWN_COMMAND = &quot;SHUTDOWN&quot;; private static boolean shutdown = false; private static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); /** * 服务器一启动就加载配置文件 */ static{ Properties prop = new Properties(); try { prop.load(new FileInputStream(WEB_ROOT + File.separator + &quot;mapper.properties&quot;)); Set set = prop.keySet(); Iterator iterator = set.iterator(); while (iterator.hasNext()) { String key = (String) iterator.next(); String value = prop.getProperty(key); map.put(key, value); } } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; OutputStream out = null; try { serverSocket = new ServerSocket(8080); while (!shutdown) { socket = serverSocket.accept(); is = socket.getInputStream(); out = socket.getOutputStream(); parse(is); if (null != url) { if(!url.equals(SHUTDOWN_COMMAND)) { if (url.indexOf(&quot;.&quot;) != -1) { sendStaticResource(out); } else { sendDynamicResource(is, out); } } else{ shutdown=true; } } } } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != is) { is.close(); } if (null != out) { out.close(); } if (null != socket) { socket.close(); } } catch (Exception e) { e.printStackTrace(); } } } /** * 解析http请求 */ private static void parse(InputStream is) throws IOException { StringBuffer httprequest = new StringBuffer(2048); byte[] bytes = new byte[2048]; int len=is.read(bytes); httprequest.append(new String(bytes, 0,len )); parseurl(httprequest); } /** * 获取http请求中的请求资源名 * * @param httprequest */ private static void parseurl(StringBuffer httprequest) { int index1, index2; index1 = httprequest.indexOf(&quot; &quot;); if (index1 != -1) { index2 = httprequest.indexOf(&quot; &quot;, index1 + 1); if (index2 &gt; index1) { url = httprequest.substring(index1 + 2, index2); } } } /** * 发送动态资源 */ private static void sendDynamicResource(InputStream is,OutputStream out) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException { out.write(&quot;HTTP/1.1 200 OK\\n&quot;.getBytes()); out.write(&quot;Server:apache-Coyote/1.1\\n&quot;.getBytes()); out.write(&quot;Content-Type:text/html;charset=utf-8\\n&quot;.getBytes()); out.write(&quot;\\n&quot;.getBytes()); //如果配置文件中的键匹配则创建Servlet实例并执行方法 if (map.containsKey(url)) { String value = map.get(url); Class clazz = Class.forName(value); Servlet servlet = (Servlet) clazz.newInstance(); servlet.init(); servlet.service(is,out); } } /** * 发送静态资源文件 */ private static void sendStaticResource(OutputStream out) { byte[] bytes = new byte[2048]; FileInputStream fis = null; try { File file = new File(WEB_ROOT, url); if (file.exists()) { out.write(&quot;HTTP/1.1 200 OK\\n&quot;.getBytes()); out.write(&quot;Server:Apache-Coyote/1.1\\n&quot;.getBytes()); out.write(&quot;Content-Type:text/html;charset=utf-8\\n&quot;.getBytes()); out.write(&quot;\\n&quot;.getBytes()); fis = new FileInputStream(file); int len = fis.read(bytes); while (len != -1) { out.write(bytes, 0, len); len = fis.read(bytes); } } else { out.write(&quot;HTTP/1.1 404 not found\\n&quot;.getBytes()); out.write(&quot;Server:apache-Coyote/1.1\\n&quot;.getBytes()); out.write(&quot;Content-Type:text/html;charset=utf-8\\n&quot;.getBytes()); out.write(&quot;\\n&quot;.getBytes()); String errorMessage = &quot;file not found&quot;; out.write(errorMessage.getBytes()); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != fis) { fis.close(); } } catch (Exception e) { e.printStackTrace(); } } } } 总算是实现了一个属于自己的破产版tocat,但在我们平时的生产中，肯定还是要站在巨人的肩膀上。tomcat本身是一个非常复杂的系统，包含了很多的功能模块，如果对tomcat本身十分感兴趣而且想了解他的架构，推荐去看《How Tomcat Works》一本全英书，如果英语和作者一样差的话可以去看《深入剖析Tomcat》,这本书对前者进行了翻译,作者会从0开始一步一步去实现tomcat的功能，读完肯定能让你对tomcat有进一步的深入。 感谢你们阅读我编写的推文！今天就介绍这么多啦，你们能够有所收获，代码也不一定完全的正确，如果我有任何写得不正确和不准确的地方，欢迎大家向我提出来，我们可以一起学习和交流！","categories":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/java/"},{"name":"tomcat","slug":"tomcat","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/tomcat/"},{"name":"servlet","slug":"servlet","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/servlet/"},{"name":"socket","slug":"socket","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/socket/"},{"name":"反射","slug":"反射","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"广度优先搜索的实际应用","slug":"广度优先搜索的实际应用","date":"2020-02-28T12:02:18.665Z","updated":"2020-02-29T06:05:10.870Z","comments":true,"path":"2020/02/28/广度优先搜索的实际应用/","link":"","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/2020/02/28/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/","excerpt":"","text":"# 广度优先搜索的实际应用 摘要: &nbsp;&nbsp;&nbsp;&nbsp;广度优先搜索常常在算法比赛中用于求搜索类型题目的最短路径问题，需要用到队列这一种数据结构.与深度优先搜索不同，广度优先搜索先搜索相邻的结点，更容易找不到目标点，使用与只需求解最优解。若需要需求全部路径，则还是选用深度优先搜索 以蓝桥杯一道简单题目作为入门 问题描述## 标题​ 学霸抢走了大家的作业，班长为了帮同学们找回作业，决定去找学霸决斗。但学霸为了不要别人打扰，住在一个城堡里，城堡外面是一个二维的格子迷宫，要进城堡必须得先通过迷宫。因为班长还有妹子要陪，磨刀不误砍柴功，他为了节约时间，从线人那里搞到了迷宫的地图，准备提前计算最短的路线。可是他现在正向妹子解释这件事情，于是就委托你帮他找一条最短的路线。 输入格式​ 第一行两个整数n， m，为迷宫的长宽。 接下来n行，每行m个数，数之间没有间隔，为0或1中的一个。0表示这个格子可以通过，1表示不可以。假设你现在已经在迷宫坐标(1,1)的地方，即左上角，迷宫的出口在(n,m)。每次移动时只能向上下左右4个方向移动到另外一个可以通过的格子里，每次移动算一步。数据保证(1,1)，(n,m)可以通过。 输出格式​ 第一行一个数为需要的最少步数K。 第二行K个字符，每个字符∈{U,D,L,R},分别表示上下左右。如果有多条长度相同的最短路径，选择在此表示方法下字典序最小的一个。 样例输入3 3001100110 样例输出4RDRD 解题思路​ 首先，本题只需要求解最短路径，并不需要求出全部路径，因此我们选用广度优先搜索，如果选用深度优先搜索搜索多余的路径必定会导致结果超时。 ​ 通常求解类似问题必定会用到队列这一数据结构。在不考虑本题情况下，广度优先搜索+队列解决最短路径问题的情况如下。 （1）将起始节点放入队列尾部 （2）While(队列不为空） 取得并删除队列首节点Node if(满足条件){ ...处理 } 处理该节点Node 把Node的未处理(即还没有入队)相邻节点加入队列尾部 ​ 有了思路后转换为代码就是轻而易举的事情了，也就是在此基础上添加题目所需的最短路径，值得注意的是，我们需要保证同一个节点不能重复进入队列。 ​ 最终代码如下 package 学霸迷宫; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; /** * @author Meng * @date 2019/10/11 */ public class Main { //下上右左 private static int[][] path = new int[][] { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } }; //用于标记每个点是否用过 private static boolean[] used[]; //用于储存每个节点的信息 static class Node { Node(int x, int y, int step,String path) { this.x = x; this.y = y; this.step = step; this.path=path; } String path; //记录走到该店的路径 int x; //记录每个点的x轴 int y; //记录每个点的y轴 int step; //几个走到该店所需要的最短步骤 } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int m = scanner.nextInt(); char[][] arr = new char[n][m]; //使用二维数组存储迷宫信息 for (int i = 0; i &lt; arr.length; i++) { String str = scanner.next(); arr[i] = str.toCharArray(); } used=new boolean[n][m]; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();//频繁的出队入列使用链表效率更好 Node node = new Node(0, 0, 0,&quot;&quot;); //添加初始点 queue.offer(node); while (queue.size() != 0) { Node poll = queue.poll(); if (poll.x == n - 1 &amp;&amp; poll.y == m - 1) { // 终止条件 System.out.println(poll.step); System.out.println(poll.path); //输出结果 break; } for (int i = 0; i &lt; 4; i++) { //for循环寻找相邻点 int xx = poll.x + path[i][0]; int yy = poll.y + path[i][1]; int step=poll.step+1; String path=&quot;&quot;; if(i==0) { path=poll.path+&quot;D&quot;; } if(i==1) { path=poll.path+&quot;U&quot;; } if(i==2){ path=poll.path+&quot;R&quot;; } if(i==3) { path=poll.path+&quot;L&quot;; } if(check(xx,yy,n,m,arr)) { queue.offer(new Node(xx,yy,step,path)); used[xx][yy]=true; } } } } private static boolean check(int xx, int yy,int n,int m,char[][] arr) { if(xx&gt;n-1||yy&gt;m-1)return false; //越界返回 if(xx&lt;0||yy&lt;0)return false; //越界返回 if(arr[xx][yy]==&#39;1&#39;)return false; //1不给走 if(used[xx][yy])return false; //已添加过的点不再添加 return true; } }","categories":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/"},{"name":"算法","slug":"java/算法","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"bfs","slug":"bfs","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/bfs/"},{"name":"队列","slug":"队列","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"算法","slug":"算法","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"HashMap的工作原理和底层实现（一）","slug":"HashMap的工作原理和底层实现（一）","date":"2020-02-28T11:56:50.889Z","updated":"2020-02-29T06:02:11.182Z","comments":true,"path":"2020/02/28/HashMap的工作原理和底层实现（一）/","link":"","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/2020/02/28/HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"HashMap的工作原理和底层实现（一） 摘要: &nbsp;&nbsp;&nbsp;&nbsp;HashMap是java最常用的容器之一，本文会先介绍一下哈希表，然后在jdk1.8的基础上，介绍HashMap的数组+链表+红黑树的原理及其它的底层实现 一、什么是哈希表 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希表是根据关键码值而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中（本文指的是数组）一个位置来访问，这个映射的函数叫做散列函数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过下面一个例子来理解哈希表以及他的好处。如果我们想要在一个数组中找到某个值的下标，我们会怎么做？ 1)顺序查找 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺序查找一般是我们能够立刻想到的，从表中的最后一个数据元素开始，逐个同记录的关键字做比较，如果匹配成功，则查找成功；反之，如果直到表中第一个关键字查找完也没有成功匹配，则查找失败。 ![](https://images2018.cnblogs.com/blog/1387338/201805/1387338-20180530200925684-1605416993.png) 因为它要一个个的找，因此它的时间复杂度是O(n) 2)二分查找 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分查找的思想和我们以前玩的猜1-100中的某个数字的游戏很相似。在确保顺序存储结构和按关键字大小有序排列的情况下 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先确定该查找区间的中间点位置： int mid = (low+upper) / 2；然后将待查找的值与中间点位置的值比较：若相等，则查找成功并返回此位置。若中间点位置值大于待查值，则新的查找区间是中间点位置的左边区域。若中间点位置值小于待查值，则新的查找区间是中间点位置的右边区域。下一次查找是针对新的查找区间进行的。 ![](https://images2018.cnblogs.com/blog/1387338/201805/1387338-20180530202324769-1418992702.png) 在最坏的情况下，我们可以设长度为n，查找次数为k，则k=log2n,则时间复杂度为O(logn) 3)哈希表查找 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还能不能更快呢？在不考虑冲突的情况下，我们可以给定一个哈希函数来得到一个数的存放位置，这样在取出这个数的时候我们可以直接通过哈希函数直接得到他的位置。这样的话，它的时间复杂度就是O(1) 但现实是残酷的，如果遇到哈希冲突（通过哈希函数算出来的位置已经被占领）,我们就要采取方法，这样时间复杂度很可能会上升。因此，为了尽量的避免哈希冲突数组的大小要大于需要存储的信息量,所以说哈希表是一个以空间换取时间的数据结构. #### 二、jdk1.8中的HashMap java中的HashMap我们主要用于存放键值对，为了保证快速的存取，HashMap的底层就是采用了哈希表的方法. ##### （1)工作原理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，在jdk1.8之前，HashMap采用的是数组+链表，在jdk1.8之后采用的是数组+链表+红黑树,本文讲述的是jdk1.8. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与之前讲述的哈希表原理相似，HashMap也是定义一个数组，初始大小为16,当我们需要放入一个键值对的时候，就会通过一个哈希函数确认存放的位置放入到相应的数组位置。如果出现哈希冲突，HashMap采用的方法是拉链法,即在数组中的每一个位置都是一个链表的形式，产生Hash冲突的键值对都会插入都该位置的链表中。大致形状如下. ![](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=801225794,2812759407&fm=26&gp=0.jpg) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在jdk1.8之前，这就是HashMap大致结构。但是这样会有一个问题，随着冲突次数的增加，链表的长度可能也会越来越长，这样查找起来就相当于遍历链表，十分消耗时间。因此在jdk1.8引入了红黑树的结构,在链表长度达到一个阙值TREEIFY_THRESHOLD(默认是8)后，便会把链表转换为红黑树,因此一个HashMap可能转化为如下形式. ![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1563442070890&di=43a31e35dfa0ac9b19fe9f4ac87b2440&imgtype=0&src=http%3A%2F%2Fwww.jobbible.cn%2Fwp-content%2Fuploads%2F2019%2F03%2Fimage-12.png) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在使用HashMap是不用关注它的大小的，是因为一开始它的初始容量为16，当当前数组已经使用的大小比上容量达到一定的比值，HashMap就会自己进行resize()扩容操作，而这个比值我们称之为加载因子,加载因子是个float变量，默认为0.75f,即当使用的数组位数达到16*0.75=12位后，HashMap就会进行扩容为容量为32，每次扩容之后的大小为之前的两倍.可能会有人疑惑，为什么不等达到刚好16位的时候才扩容呢？ ![](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1243458070,1898910952&fm=26&gp=0.jpg) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那是因为在前面我们已经讲过HashMap是一个以空间换取时间的数据结构，因此才需要一个适当扩容因子，既不能太高降低速度也不能太低空间浪费过多。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得一提的是，通过阅读源码在jdk1.8之前链表插入使用的是头插法，即新插入的值总是放在最前面,可能是认为最新插入的可能是比之前插入的更频繁使用。但是在jdk1.8链表的插入使用的是尾插法，我也暂时不知道改动的意义在哪里. #### （2底层实现HashMap所具有的一些属性 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; DEFAULT_INITIAL_CAPACITY:上文提到的初始容量大小，&lt;&lt;符号为区分正负数的左移,这里指把1左移4位，即16. MAXIMUM_CAPACITY:HashMap容量的最大限制,为2的30次方. DEFAULT_LOAD_FACTOR:加载因子，前面已经提过，默认为0.75f. TREEIFY_THRESHOLD:前面也已经提过，链表转化为红黑树的阙值. UNTREEIFY_THRESHOLD：在HashMap扩容的时候，重新调整整个结构，如果链表的长度小于6且该位置已经转化为树，就退化为链表. MIN_TREEIFY_CAPACITY: 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。 HashMap的构造方法（注释对构造函数进行了说明） //该方法返回大于等于cap最相近的2的2次幂数，例如cap=256,返回256,cap=257，返回512，返回不会大于最大容量 static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } public HashMap(int initialCapacity, float loadFactor) { //如果初始化容量大小小于0，抛出异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); //如果初始化容量大小大于最大容量大小，初始化容量大小就等于最大容量大小 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //如果加载因子小于等于0，且加载因子并不是一个数字则抛出参数不合法异常 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); //一切正常后，初始化加载因子， this.loadFactor = loadFactor; //threshold为loadFactor*容量，对于指定了初始化大小的HashMap，它的threshold为大于等于initialCapacity最相近的2的2次幂 this.threshold = tableSizeFor(initialCapacity); } public HashMap(int initialCapacity) { //直接调用上一个构造函数，没有给定加载因子就以默认的加载因子 this(initialCapacity, DEFAULT_LOAD_FACTOR); } public HashMap() { //什么都不给就只初始化默认加载因子 this.loadFactor = DEFAULT_LOAD_FACTOR; } //构造一个新的 HashMap与指定的相同的映射 Map 。 public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; //构造两个相同的Map的初始化工作 putMapEntries(m, false); } 考虑到减少HashMap的扩容次数。 > 这里有一个小建议：在初始化HashMap的时候，应该尽量指定其大小。尤其是当你已知map中存放的元素个数时。（《阿里巴巴Java开发规约》） HashMap的哈希函数 //重写Object的hashCode方法，采用键的哈希值异或上值的哈希值 public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } //哈希函数，键位null哈希值为null，否则就是key的hash值的高位（16位）与低位进行异或 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 注意,^为异或的符号.这样做的好处是，混合原始哈希码的高位和地位，以此来加大低位的随机性。这里面对jdk1.8之前的hash函数进行了优化，有兴趣的可以去查看一下源码和了解一下扰动函数的细节。 HashMap的put函数 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果数组为空，则进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果相对应位置没有链表，则新建有一个结点 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; //如果插入结点的哈希值和key值相同的话，直接放入该结点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //如果给到的结点是红黑树结点，就进行红黑树插入 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { //for循环遍历整个链表，如果大于阙值则转化为树，否则尾插法插入 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //该方法用于对链表转化为树 treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } //结点的插入 if (e != null) { V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; //如果已经占用的数组位数大于threshold，则进行resize()扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } HashMap中的put是我们最常用的方法之一了,从tab[i = (n - 1) & hash]我们可以看出，最后得到数组存放位置的方法是用数组长度减一逻辑与上之前我们算出来的hash值.整个函数中没有特别复杂的操作，且都是if判断语句，所以我们大致认为它的时间复杂度为O(1).至此，整个HashMap确定数组位置我们已经搞清楚了. HashMap的resize()函数用于扩容，并且调整扩容后的位置，这里不说明. HashMap的get函数 public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //首先保证数组不会空，且该位置的头结点不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { //链表的头结点直接找到 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { //如果该链表已经转化为红黑树，就调用相对应的红黑树的查找方法 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //对链表的遍历查找 do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 有了前面的基础后，对于get函数的理解也是相较来说比较容易的.整个流程下来，消耗时间最多的就在于链表的查询，又因为链表的长度不大于8，因此我们也可以大致认为时间复杂度为O(1) #### 小结 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们平时使用HashMap，我们并不用关注它的原理，但是不点开不知道，其中蕴含了这么多的学问。甚至有没有想过为什么加载因子制作者刚好设置为0.75f，这里面涉及到了统计学。,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布。用0.75作为加载因子，数组中元素到达8个的时候，概率已经变得非常小.除此之外还有一个好处就是数组的扩容都是2倍来进行的，因为0.75*2必定是个整数,因此扩容后的阙值不会出现小数的情况.还有HashMap是线程不安全的，如果两个线程同时进行访问，会导致一些错误. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次的文章就写到这里，因篇幅关系这次并没有介绍HashMap中的红黑树，希望下次有机会进行介绍.感兴趣的可以自己去查找下资料进行了解。对于文章中不足的地方，欢迎指出我们一起交流.","categories":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/java/"},{"name":"hashmap","slug":"hashmap","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/hashmap/"},{"name":"数据结构","slug":"数据结构","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"红黑树","slug":"红黑树","permalink":"https://look-ahead8.github.io/Look-Ahead8-github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"}]}]}